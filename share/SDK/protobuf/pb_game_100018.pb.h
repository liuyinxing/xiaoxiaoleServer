// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb_game_100018.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pb_5fgame_5f100018_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pb_5fgame_5f100018_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pb_5fgame_5f100018_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pb_5fgame_5f100018_2eproto {
  static const uint32_t offsets[];
};
namespace pb_game_100018 {
class cs_change_bet;
struct cs_change_betDefaultTypeInternal;
extern cs_change_betDefaultTypeInternal _cs_change_bet_default_instance_;
class cs_game_roll;
struct cs_game_rollDefaultTypeInternal;
extern cs_game_rollDefaultTypeInternal _cs_game_roll_default_instance_;
class lineHit;
struct lineHitDefaultTypeInternal;
extern lineHitDefaultTypeInternal _lineHit_default_instance_;
class sc_change_bet;
struct sc_change_betDefaultTypeInternal;
extern sc_change_betDefaultTypeInternal _sc_change_bet_default_instance_;
class sc_game_info;
struct sc_game_infoDefaultTypeInternal;
extern sc_game_infoDefaultTypeInternal _sc_game_info_default_instance_;
class sc_game_roll;
struct sc_game_rollDefaultTypeInternal;
extern sc_game_rollDefaultTypeInternal _sc_game_roll_default_instance_;
}  // namespace pb_game_100018
PROTOBUF_NAMESPACE_OPEN
template<> ::pb_game_100018::cs_change_bet* Arena::CreateMaybeMessage<::pb_game_100018::cs_change_bet>(Arena*);
template<> ::pb_game_100018::cs_game_roll* Arena::CreateMaybeMessage<::pb_game_100018::cs_game_roll>(Arena*);
template<> ::pb_game_100018::lineHit* Arena::CreateMaybeMessage<::pb_game_100018::lineHit>(Arena*);
template<> ::pb_game_100018::sc_change_bet* Arena::CreateMaybeMessage<::pb_game_100018::sc_change_bet>(Arena*);
template<> ::pb_game_100018::sc_game_info* Arena::CreateMaybeMessage<::pb_game_100018::sc_game_info>(Arena*);
template<> ::pb_game_100018::sc_game_roll* Arena::CreateMaybeMessage<::pb_game_100018::sc_game_roll>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb_game_100018 {

enum cmd_code : int {
  mdm_game_notify = 180,
  ass_game_roll = 80,
  ass_game_change_bet = 83
};
bool cmd_code_IsValid(int value);
constexpr cmd_code cmd_code_MIN = ass_game_roll;
constexpr cmd_code cmd_code_MAX = mdm_game_notify;
constexpr int cmd_code_ARRAYSIZE = cmd_code_MAX + 1;

const std::string& cmd_code_Name(cmd_code value);
template<typename T>
inline const std::string& cmd_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, cmd_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function cmd_code_Name.");
  return cmd_code_Name(static_cast<cmd_code>(enum_t_value));
}
bool cmd_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, cmd_code* value);
enum error_code : int {
  roll_bet_invalide = 1,
  roll_score_not_enough = 2,
  roll_mode_is_error = 3
};
bool error_code_IsValid(int value);
constexpr error_code error_code_MIN = roll_bet_invalide;
constexpr error_code error_code_MAX = roll_mode_is_error;
constexpr int error_code_ARRAYSIZE = error_code_MAX + 1;

const std::string& error_code_Name(error_code value);
template<typename T>
inline const std::string& error_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, error_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function error_code_Name.");
  return error_code_Name(static_cast<error_code>(enum_t_value));
}
bool error_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, error_code* value);
// ===================================================================

class lineHit final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pb_game_100018.lineHit) */ {
 public:
  inline lineHit() : lineHit(nullptr) {}
  ~lineHit() override;
  explicit PROTOBUF_CONSTEXPR lineHit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  lineHit(const lineHit& from);
  lineHit(lineHit&& from) noexcept
    : lineHit() {
    *this = ::std::move(from);
  }

  inline lineHit& operator=(const lineHit& from) {
    CopyFrom(from);
    return *this;
  }
  inline lineHit& operator=(lineHit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const lineHit& default_instance() {
    return *internal_default_instance();
  }
  static inline const lineHit* internal_default_instance() {
    return reinterpret_cast<const lineHit*>(
               &_lineHit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(lineHit& a, lineHit& b) {
    a.Swap(&b);
  }
  inline void Swap(lineHit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(lineHit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  lineHit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<lineHit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const lineHit& from);
  void MergeFrom(const lineHit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(lineHit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb_game_100018.lineHit";
  }
  protected:
  explicit lineHit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellIdxFieldNumber = 2,
    kLineNumFieldNumber = 1,
  };
  // repeated int32 cellIdx = 2;
  int cellidx_size() const;
  private:
  int _internal_cellidx_size() const;
  public:
  void clear_cellidx();
  private:
  int32_t _internal_cellidx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_cellidx() const;
  void _internal_add_cellidx(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_cellidx();
  public:
  int32_t cellidx(int index) const;
  void set_cellidx(int index, int32_t value);
  void add_cellidx(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      cellidx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_cellidx();

  // required int32 lineNum = 1;
  bool has_linenum() const;
  private:
  bool _internal_has_linenum() const;
  public:
  void clear_linenum();
  int32_t linenum() const;
  void set_linenum(int32_t value);
  private:
  int32_t _internal_linenum() const;
  void _internal_set_linenum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb_game_100018.lineHit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > cellidx_;
    int32_t linenum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_5fgame_5f100018_2eproto;
};
// -------------------------------------------------------------------

class cs_change_bet final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pb_game_100018.cs_change_bet) */ {
 public:
  inline cs_change_bet() : cs_change_bet(nullptr) {}
  ~cs_change_bet() override;
  explicit PROTOBUF_CONSTEXPR cs_change_bet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  cs_change_bet(const cs_change_bet& from);
  cs_change_bet(cs_change_bet&& from) noexcept
    : cs_change_bet() {
    *this = ::std::move(from);
  }

  inline cs_change_bet& operator=(const cs_change_bet& from) {
    CopyFrom(from);
    return *this;
  }
  inline cs_change_bet& operator=(cs_change_bet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const cs_change_bet& default_instance() {
    return *internal_default_instance();
  }
  static inline const cs_change_bet* internal_default_instance() {
    return reinterpret_cast<const cs_change_bet*>(
               &_cs_change_bet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(cs_change_bet& a, cs_change_bet& b) {
    a.Swap(&b);
  }
  inline void Swap(cs_change_bet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(cs_change_bet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  cs_change_bet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<cs_change_bet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const cs_change_bet& from);
  void MergeFrom(const cs_change_bet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(cs_change_bet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb_game_100018.cs_change_bet";
  }
  protected:
  explicit cs_change_bet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseBetFieldNumber = 1,
  };
  // required int64 baseBet = 1;
  bool has_basebet() const;
  private:
  bool _internal_has_basebet() const;
  public:
  void clear_basebet();
  int64_t basebet() const;
  void set_basebet(int64_t value);
  private:
  int64_t _internal_basebet() const;
  void _internal_set_basebet(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb_game_100018.cs_change_bet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t basebet_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_5fgame_5f100018_2eproto;
};
// -------------------------------------------------------------------

class sc_change_bet final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pb_game_100018.sc_change_bet) */ {
 public:
  inline sc_change_bet() : sc_change_bet(nullptr) {}
  ~sc_change_bet() override;
  explicit PROTOBUF_CONSTEXPR sc_change_bet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sc_change_bet(const sc_change_bet& from);
  sc_change_bet(sc_change_bet&& from) noexcept
    : sc_change_bet() {
    *this = ::std::move(from);
  }

  inline sc_change_bet& operator=(const sc_change_bet& from) {
    CopyFrom(from);
    return *this;
  }
  inline sc_change_bet& operator=(sc_change_bet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const sc_change_bet& default_instance() {
    return *internal_default_instance();
  }
  static inline const sc_change_bet* internal_default_instance() {
    return reinterpret_cast<const sc_change_bet*>(
               &_sc_change_bet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(sc_change_bet& a, sc_change_bet& b) {
    a.Swap(&b);
  }
  inline void Swap(sc_change_bet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sc_change_bet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sc_change_bet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sc_change_bet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const sc_change_bet& from);
  void MergeFrom(const sc_change_bet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(sc_change_bet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb_game_100018.sc_change_bet";
  }
  protected:
  explicit sc_change_bet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultipleNumberFieldNumber = 1,
  };
  // required int32 multiple_number = 1;
  bool has_multiple_number() const;
  private:
  bool _internal_has_multiple_number() const;
  public:
  void clear_multiple_number();
  int32_t multiple_number() const;
  void set_multiple_number(int32_t value);
  private:
  int32_t _internal_multiple_number() const;
  void _internal_set_multiple_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb_game_100018.sc_change_bet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t multiple_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_5fgame_5f100018_2eproto;
};
// -------------------------------------------------------------------

class sc_game_info final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pb_game_100018.sc_game_info) */ {
 public:
  inline sc_game_info() : sc_game_info(nullptr) {}
  ~sc_game_info() override;
  explicit PROTOBUF_CONSTEXPR sc_game_info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sc_game_info(const sc_game_info& from);
  sc_game_info(sc_game_info&& from) noexcept
    : sc_game_info() {
    *this = ::std::move(from);
  }

  inline sc_game_info& operator=(const sc_game_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline sc_game_info& operator=(sc_game_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const sc_game_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const sc_game_info* internal_default_instance() {
    return reinterpret_cast<const sc_game_info*>(
               &_sc_game_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(sc_game_info& a, sc_game_info& b) {
    a.Swap(&b);
  }
  inline void Swap(sc_game_info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sc_game_info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sc_game_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sc_game_info>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const sc_game_info& from);
  void MergeFrom(const sc_game_info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(sc_game_info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb_game_100018.sc_game_info";
  }
  protected:
  explicit sc_game_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameinfoFieldNumber = 1,
    kGameLineFieldNumber = 2,
    kDefaultBetFieldNumber = 3,
  };
  // required .pb_game_100018.sc_game_roll gameinfo = 1;
  bool has_gameinfo() const;
  private:
  bool _internal_has_gameinfo() const;
  public:
  void clear_gameinfo();
  const ::pb_game_100018::sc_game_roll& gameinfo() const;
  PROTOBUF_NODISCARD ::pb_game_100018::sc_game_roll* release_gameinfo();
  ::pb_game_100018::sc_game_roll* mutable_gameinfo();
  void set_allocated_gameinfo(::pb_game_100018::sc_game_roll* gameinfo);
  private:
  const ::pb_game_100018::sc_game_roll& _internal_gameinfo() const;
  ::pb_game_100018::sc_game_roll* _internal_mutable_gameinfo();
  public:
  void unsafe_arena_set_allocated_gameinfo(
      ::pb_game_100018::sc_game_roll* gameinfo);
  ::pb_game_100018::sc_game_roll* unsafe_arena_release_gameinfo();

  // required int32 gameLine = 2;
  bool has_gameline() const;
  private:
  bool _internal_has_gameline() const;
  public:
  void clear_gameline();
  int32_t gameline() const;
  void set_gameline(int32_t value);
  private:
  int32_t _internal_gameline() const;
  void _internal_set_gameline(int32_t value);
  public:

  // required int32 defaultBet = 3;
  bool has_defaultbet() const;
  private:
  bool _internal_has_defaultbet() const;
  public:
  void clear_defaultbet();
  int32_t defaultbet() const;
  void set_defaultbet(int32_t value);
  private:
  int32_t _internal_defaultbet() const;
  void _internal_set_defaultbet(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb_game_100018.sc_game_info)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::pb_game_100018::sc_game_roll* gameinfo_;
    int32_t gameline_;
    int32_t defaultbet_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_5fgame_5f100018_2eproto;
};
// -------------------------------------------------------------------

class cs_game_roll final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pb_game_100018.cs_game_roll) */ {
 public:
  inline cs_game_roll() : cs_game_roll(nullptr) {}
  ~cs_game_roll() override;
  explicit PROTOBUF_CONSTEXPR cs_game_roll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  cs_game_roll(const cs_game_roll& from);
  cs_game_roll(cs_game_roll&& from) noexcept
    : cs_game_roll() {
    *this = ::std::move(from);
  }

  inline cs_game_roll& operator=(const cs_game_roll& from) {
    CopyFrom(from);
    return *this;
  }
  inline cs_game_roll& operator=(cs_game_roll&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const cs_game_roll& default_instance() {
    return *internal_default_instance();
  }
  static inline const cs_game_roll* internal_default_instance() {
    return reinterpret_cast<const cs_game_roll*>(
               &_cs_game_roll_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(cs_game_roll& a, cs_game_roll& b) {
    a.Swap(&b);
  }
  inline void Swap(cs_game_roll* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(cs_game_roll* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  cs_game_roll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<cs_game_roll>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const cs_game_roll& from);
  void MergeFrom(const cs_game_roll& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(cs_game_roll* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb_game_100018.cs_game_roll";
  }
  protected:
  explicit cs_game_roll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBetScoreFieldNumber = 1,
  };
  // required int64 betScore = 1;
  bool has_betscore() const;
  private:
  bool _internal_has_betscore() const;
  public:
  void clear_betscore();
  int64_t betscore() const;
  void set_betscore(int64_t value);
  private:
  int64_t _internal_betscore() const;
  void _internal_set_betscore(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb_game_100018.cs_game_roll)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t betscore_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_5fgame_5f100018_2eproto;
};
// -------------------------------------------------------------------

class sc_game_roll final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pb_game_100018.sc_game_roll) */ {
 public:
  inline sc_game_roll() : sc_game_roll(nullptr) {}
  ~sc_game_roll() override;
  explicit PROTOBUF_CONSTEXPR sc_game_roll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sc_game_roll(const sc_game_roll& from);
  sc_game_roll(sc_game_roll&& from) noexcept
    : sc_game_roll() {
    *this = ::std::move(from);
  }

  inline sc_game_roll& operator=(const sc_game_roll& from) {
    CopyFrom(from);
    return *this;
  }
  inline sc_game_roll& operator=(sc_game_roll&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const sc_game_roll& default_instance() {
    return *internal_default_instance();
  }
  static inline const sc_game_roll* internal_default_instance() {
    return reinterpret_cast<const sc_game_roll*>(
               &_sc_game_roll_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(sc_game_roll& a, sc_game_roll& b) {
    a.Swap(&b);
  }
  inline void Swap(sc_game_roll* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sc_game_roll* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sc_game_roll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sc_game_roll>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const sc_game_roll& from);
  void MergeFrom(const sc_game_roll& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(sc_game_roll* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb_game_100018.sc_game_roll";
  }
  protected:
  explicit sc_game_roll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultCellsFieldNumber = 12,
    kHitCellsFieldNumber = 13,
    kHitLinesFieldNumber = 14,
    kCurrentModeFieldNumber = 1,
    kNextModeFieldNumber = 2,
    kWinScoreFieldNumber = 3,
    kFreetotalwinScoreFieldNumber = 4,
    kJackpotFieldNumber = 5,
    kWinTypeFieldNumber = 6,
    kFreeCountFieldNumber = 7,
    kFreeAllCountFieldNumber = 8,
    kMultipleNumberFieldNumber = 9,
    kBetScoreFieldNumber = 11,
    kUserScoreFieldNumber = 15,
    kMultipleNumberFreeFieldNumber = 10,
  };
  // repeated int32 resultCells = 12;
  int resultcells_size() const;
  private:
  int _internal_resultcells_size() const;
  public:
  void clear_resultcells();
  private:
  int32_t _internal_resultcells(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_resultcells() const;
  void _internal_add_resultcells(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_resultcells();
  public:
  int32_t resultcells(int index) const;
  void set_resultcells(int index, int32_t value);
  void add_resultcells(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      resultcells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_resultcells();

  // repeated int32 hitCells = 13;
  int hitcells_size() const;
  private:
  int _internal_hitcells_size() const;
  public:
  void clear_hitcells();
  private:
  int32_t _internal_hitcells(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_hitcells() const;
  void _internal_add_hitcells(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_hitcells();
  public:
  int32_t hitcells(int index) const;
  void set_hitcells(int index, int32_t value);
  void add_hitcells(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      hitcells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_hitcells();

  // repeated .pb_game_100018.lineHit hitLines = 14;
  int hitlines_size() const;
  private:
  int _internal_hitlines_size() const;
  public:
  void clear_hitlines();
  ::pb_game_100018::lineHit* mutable_hitlines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb_game_100018::lineHit >*
      mutable_hitlines();
  private:
  const ::pb_game_100018::lineHit& _internal_hitlines(int index) const;
  ::pb_game_100018::lineHit* _internal_add_hitlines();
  public:
  const ::pb_game_100018::lineHit& hitlines(int index) const;
  ::pb_game_100018::lineHit* add_hitlines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb_game_100018::lineHit >&
      hitlines() const;

  // required int32 currentMode = 1;
  bool has_currentmode() const;
  private:
  bool _internal_has_currentmode() const;
  public:
  void clear_currentmode();
  int32_t currentmode() const;
  void set_currentmode(int32_t value);
  private:
  int32_t _internal_currentmode() const;
  void _internal_set_currentmode(int32_t value);
  public:

  // required int32 nextMode = 2;
  bool has_nextmode() const;
  private:
  bool _internal_has_nextmode() const;
  public:
  void clear_nextmode();
  int32_t nextmode() const;
  void set_nextmode(int32_t value);
  private:
  int32_t _internal_nextmode() const;
  void _internal_set_nextmode(int32_t value);
  public:

  // required int64 winScore = 3;
  bool has_winscore() const;
  private:
  bool _internal_has_winscore() const;
  public:
  void clear_winscore();
  int64_t winscore() const;
  void set_winscore(int64_t value);
  private:
  int64_t _internal_winscore() const;
  void _internal_set_winscore(int64_t value);
  public:

  // required int64 freetotalwinScore = 4;
  bool has_freetotalwinscore() const;
  private:
  bool _internal_has_freetotalwinscore() const;
  public:
  void clear_freetotalwinscore();
  int64_t freetotalwinscore() const;
  void set_freetotalwinscore(int64_t value);
  private:
  int64_t _internal_freetotalwinscore() const;
  void _internal_set_freetotalwinscore(int64_t value);
  public:

  // required int64 jackpot = 5;
  bool has_jackpot() const;
  private:
  bool _internal_has_jackpot() const;
  public:
  void clear_jackpot();
  int64_t jackpot() const;
  void set_jackpot(int64_t value);
  private:
  int64_t _internal_jackpot() const;
  void _internal_set_jackpot(int64_t value);
  public:

  // required int32 winType = 6;
  bool has_wintype() const;
  private:
  bool _internal_has_wintype() const;
  public:
  void clear_wintype();
  int32_t wintype() const;
  void set_wintype(int32_t value);
  private:
  int32_t _internal_wintype() const;
  void _internal_set_wintype(int32_t value);
  public:

  // required int32 freeCount = 7;
  bool has_freecount() const;
  private:
  bool _internal_has_freecount() const;
  public:
  void clear_freecount();
  int32_t freecount() const;
  void set_freecount(int32_t value);
  private:
  int32_t _internal_freecount() const;
  void _internal_set_freecount(int32_t value);
  public:

  // required int32 freeAllCount = 8;
  bool has_freeallcount() const;
  private:
  bool _internal_has_freeallcount() const;
  public:
  void clear_freeallcount();
  int32_t freeallcount() const;
  void set_freeallcount(int32_t value);
  private:
  int32_t _internal_freeallcount() const;
  void _internal_set_freeallcount(int32_t value);
  public:

  // required int32 multiple_number = 9;
  bool has_multiple_number() const;
  private:
  bool _internal_has_multiple_number() const;
  public:
  void clear_multiple_number();
  int32_t multiple_number() const;
  void set_multiple_number(int32_t value);
  private:
  int32_t _internal_multiple_number() const;
  void _internal_set_multiple_number(int32_t value);
  public:

  // required int64 betScore = 11;
  bool has_betscore() const;
  private:
  bool _internal_has_betscore() const;
  public:
  void clear_betscore();
  int64_t betscore() const;
  void set_betscore(int64_t value);
  private:
  int64_t _internal_betscore() const;
  void _internal_set_betscore(int64_t value);
  public:

  // required int64 userScore = 15;
  bool has_userscore() const;
  private:
  bool _internal_has_userscore() const;
  public:
  void clear_userscore();
  int64_t userscore() const;
  void set_userscore(int64_t value);
  private:
  int64_t _internal_userscore() const;
  void _internal_set_userscore(int64_t value);
  public:

  // required int32 multiple_numberFree = 10;
  bool has_multiple_numberfree() const;
  private:
  bool _internal_has_multiple_numberfree() const;
  public:
  void clear_multiple_numberfree();
  int32_t multiple_numberfree() const;
  void set_multiple_numberfree(int32_t value);
  private:
  int32_t _internal_multiple_numberfree() const;
  void _internal_set_multiple_numberfree(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb_game_100018.sc_game_roll)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > resultcells_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > hitcells_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb_game_100018::lineHit > hitlines_;
    int32_t currentmode_;
    int32_t nextmode_;
    int64_t winscore_;
    int64_t freetotalwinscore_;
    int64_t jackpot_;
    int32_t wintype_;
    int32_t freecount_;
    int32_t freeallcount_;
    int32_t multiple_number_;
    int64_t betscore_;
    int64_t userscore_;
    int32_t multiple_numberfree_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_5fgame_5f100018_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// lineHit

// required int32 lineNum = 1;
inline bool lineHit::_internal_has_linenum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool lineHit::has_linenum() const {
  return _internal_has_linenum();
}
inline void lineHit::clear_linenum() {
  _impl_.linenum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t lineHit::_internal_linenum() const {
  return _impl_.linenum_;
}
inline int32_t lineHit::linenum() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.lineHit.lineNum)
  return _internal_linenum();
}
inline void lineHit::_internal_set_linenum(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.linenum_ = value;
}
inline void lineHit::set_linenum(int32_t value) {
  _internal_set_linenum(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.lineHit.lineNum)
}

// repeated int32 cellIdx = 2;
inline int lineHit::_internal_cellidx_size() const {
  return _impl_.cellidx_.size();
}
inline int lineHit::cellidx_size() const {
  return _internal_cellidx_size();
}
inline void lineHit::clear_cellidx() {
  _impl_.cellidx_.Clear();
}
inline int32_t lineHit::_internal_cellidx(int index) const {
  return _impl_.cellidx_.Get(index);
}
inline int32_t lineHit::cellidx(int index) const {
  // @@protoc_insertion_point(field_get:pb_game_100018.lineHit.cellIdx)
  return _internal_cellidx(index);
}
inline void lineHit::set_cellidx(int index, int32_t value) {
  _impl_.cellidx_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb_game_100018.lineHit.cellIdx)
}
inline void lineHit::_internal_add_cellidx(int32_t value) {
  _impl_.cellidx_.Add(value);
}
inline void lineHit::add_cellidx(int32_t value) {
  _internal_add_cellidx(value);
  // @@protoc_insertion_point(field_add:pb_game_100018.lineHit.cellIdx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
lineHit::_internal_cellidx() const {
  return _impl_.cellidx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
lineHit::cellidx() const {
  // @@protoc_insertion_point(field_list:pb_game_100018.lineHit.cellIdx)
  return _internal_cellidx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
lineHit::_internal_mutable_cellidx() {
  return &_impl_.cellidx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
lineHit::mutable_cellidx() {
  // @@protoc_insertion_point(field_mutable_list:pb_game_100018.lineHit.cellIdx)
  return _internal_mutable_cellidx();
}

// -------------------------------------------------------------------

// cs_change_bet

// required int64 baseBet = 1;
inline bool cs_change_bet::_internal_has_basebet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool cs_change_bet::has_basebet() const {
  return _internal_has_basebet();
}
inline void cs_change_bet::clear_basebet() {
  _impl_.basebet_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t cs_change_bet::_internal_basebet() const {
  return _impl_.basebet_;
}
inline int64_t cs_change_bet::basebet() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.cs_change_bet.baseBet)
  return _internal_basebet();
}
inline void cs_change_bet::_internal_set_basebet(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.basebet_ = value;
}
inline void cs_change_bet::set_basebet(int64_t value) {
  _internal_set_basebet(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.cs_change_bet.baseBet)
}

// -------------------------------------------------------------------

// sc_change_bet

// required int32 multiple_number = 1;
inline bool sc_change_bet::_internal_has_multiple_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool sc_change_bet::has_multiple_number() const {
  return _internal_has_multiple_number();
}
inline void sc_change_bet::clear_multiple_number() {
  _impl_.multiple_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t sc_change_bet::_internal_multiple_number() const {
  return _impl_.multiple_number_;
}
inline int32_t sc_change_bet::multiple_number() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_change_bet.multiple_number)
  return _internal_multiple_number();
}
inline void sc_change_bet::_internal_set_multiple_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.multiple_number_ = value;
}
inline void sc_change_bet::set_multiple_number(int32_t value) {
  _internal_set_multiple_number(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_change_bet.multiple_number)
}

// -------------------------------------------------------------------

// sc_game_info

// required .pb_game_100018.sc_game_roll gameinfo = 1;
inline bool sc_game_info::_internal_has_gameinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gameinfo_ != nullptr);
  return value;
}
inline bool sc_game_info::has_gameinfo() const {
  return _internal_has_gameinfo();
}
inline void sc_game_info::clear_gameinfo() {
  if (_impl_.gameinfo_ != nullptr) _impl_.gameinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pb_game_100018::sc_game_roll& sc_game_info::_internal_gameinfo() const {
  const ::pb_game_100018::sc_game_roll* p = _impl_.gameinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb_game_100018::sc_game_roll&>(
      ::pb_game_100018::_sc_game_roll_default_instance_);
}
inline const ::pb_game_100018::sc_game_roll& sc_game_info::gameinfo() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_info.gameinfo)
  return _internal_gameinfo();
}
inline void sc_game_info::unsafe_arena_set_allocated_gameinfo(
    ::pb_game_100018::sc_game_roll* gameinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gameinfo_);
  }
  _impl_.gameinfo_ = gameinfo;
  if (gameinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb_game_100018.sc_game_info.gameinfo)
}
inline ::pb_game_100018::sc_game_roll* sc_game_info::release_gameinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pb_game_100018::sc_game_roll* temp = _impl_.gameinfo_;
  _impl_.gameinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb_game_100018::sc_game_roll* sc_game_info::unsafe_arena_release_gameinfo() {
  // @@protoc_insertion_point(field_release:pb_game_100018.sc_game_info.gameinfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pb_game_100018::sc_game_roll* temp = _impl_.gameinfo_;
  _impl_.gameinfo_ = nullptr;
  return temp;
}
inline ::pb_game_100018::sc_game_roll* sc_game_info::_internal_mutable_gameinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.gameinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb_game_100018::sc_game_roll>(GetArenaForAllocation());
    _impl_.gameinfo_ = p;
  }
  return _impl_.gameinfo_;
}
inline ::pb_game_100018::sc_game_roll* sc_game_info::mutable_gameinfo() {
  ::pb_game_100018::sc_game_roll* _msg = _internal_mutable_gameinfo();
  // @@protoc_insertion_point(field_mutable:pb_game_100018.sc_game_info.gameinfo)
  return _msg;
}
inline void sc_game_info::set_allocated_gameinfo(::pb_game_100018::sc_game_roll* gameinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gameinfo_;
  }
  if (gameinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gameinfo);
    if (message_arena != submessage_arena) {
      gameinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gameinfo_ = gameinfo;
  // @@protoc_insertion_point(field_set_allocated:pb_game_100018.sc_game_info.gameinfo)
}

// required int32 gameLine = 2;
inline bool sc_game_info::_internal_has_gameline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool sc_game_info::has_gameline() const {
  return _internal_has_gameline();
}
inline void sc_game_info::clear_gameline() {
  _impl_.gameline_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t sc_game_info::_internal_gameline() const {
  return _impl_.gameline_;
}
inline int32_t sc_game_info::gameline() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_info.gameLine)
  return _internal_gameline();
}
inline void sc_game_info::_internal_set_gameline(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gameline_ = value;
}
inline void sc_game_info::set_gameline(int32_t value) {
  _internal_set_gameline(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_info.gameLine)
}

// required int32 defaultBet = 3;
inline bool sc_game_info::_internal_has_defaultbet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool sc_game_info::has_defaultbet() const {
  return _internal_has_defaultbet();
}
inline void sc_game_info::clear_defaultbet() {
  _impl_.defaultbet_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t sc_game_info::_internal_defaultbet() const {
  return _impl_.defaultbet_;
}
inline int32_t sc_game_info::defaultbet() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_info.defaultBet)
  return _internal_defaultbet();
}
inline void sc_game_info::_internal_set_defaultbet(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.defaultbet_ = value;
}
inline void sc_game_info::set_defaultbet(int32_t value) {
  _internal_set_defaultbet(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_info.defaultBet)
}

// -------------------------------------------------------------------

// cs_game_roll

// required int64 betScore = 1;
inline bool cs_game_roll::_internal_has_betscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool cs_game_roll::has_betscore() const {
  return _internal_has_betscore();
}
inline void cs_game_roll::clear_betscore() {
  _impl_.betscore_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t cs_game_roll::_internal_betscore() const {
  return _impl_.betscore_;
}
inline int64_t cs_game_roll::betscore() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.cs_game_roll.betScore)
  return _internal_betscore();
}
inline void cs_game_roll::_internal_set_betscore(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.betscore_ = value;
}
inline void cs_game_roll::set_betscore(int64_t value) {
  _internal_set_betscore(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.cs_game_roll.betScore)
}

// -------------------------------------------------------------------

// sc_game_roll

// required int32 currentMode = 1;
inline bool sc_game_roll::_internal_has_currentmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool sc_game_roll::has_currentmode() const {
  return _internal_has_currentmode();
}
inline void sc_game_roll::clear_currentmode() {
  _impl_.currentmode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t sc_game_roll::_internal_currentmode() const {
  return _impl_.currentmode_;
}
inline int32_t sc_game_roll::currentmode() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.currentMode)
  return _internal_currentmode();
}
inline void sc_game_roll::_internal_set_currentmode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currentmode_ = value;
}
inline void sc_game_roll::set_currentmode(int32_t value) {
  _internal_set_currentmode(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.currentMode)
}

// required int32 nextMode = 2;
inline bool sc_game_roll::_internal_has_nextmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool sc_game_roll::has_nextmode() const {
  return _internal_has_nextmode();
}
inline void sc_game_roll::clear_nextmode() {
  _impl_.nextmode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t sc_game_roll::_internal_nextmode() const {
  return _impl_.nextmode_;
}
inline int32_t sc_game_roll::nextmode() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.nextMode)
  return _internal_nextmode();
}
inline void sc_game_roll::_internal_set_nextmode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nextmode_ = value;
}
inline void sc_game_roll::set_nextmode(int32_t value) {
  _internal_set_nextmode(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.nextMode)
}

// required int64 winScore = 3;
inline bool sc_game_roll::_internal_has_winscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool sc_game_roll::has_winscore() const {
  return _internal_has_winscore();
}
inline void sc_game_roll::clear_winscore() {
  _impl_.winscore_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t sc_game_roll::_internal_winscore() const {
  return _impl_.winscore_;
}
inline int64_t sc_game_roll::winscore() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.winScore)
  return _internal_winscore();
}
inline void sc_game_roll::_internal_set_winscore(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.winscore_ = value;
}
inline void sc_game_roll::set_winscore(int64_t value) {
  _internal_set_winscore(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.winScore)
}

// required int64 freetotalwinScore = 4;
inline bool sc_game_roll::_internal_has_freetotalwinscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool sc_game_roll::has_freetotalwinscore() const {
  return _internal_has_freetotalwinscore();
}
inline void sc_game_roll::clear_freetotalwinscore() {
  _impl_.freetotalwinscore_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t sc_game_roll::_internal_freetotalwinscore() const {
  return _impl_.freetotalwinscore_;
}
inline int64_t sc_game_roll::freetotalwinscore() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.freetotalwinScore)
  return _internal_freetotalwinscore();
}
inline void sc_game_roll::_internal_set_freetotalwinscore(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.freetotalwinscore_ = value;
}
inline void sc_game_roll::set_freetotalwinscore(int64_t value) {
  _internal_set_freetotalwinscore(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.freetotalwinScore)
}

// required int64 jackpot = 5;
inline bool sc_game_roll::_internal_has_jackpot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool sc_game_roll::has_jackpot() const {
  return _internal_has_jackpot();
}
inline void sc_game_roll::clear_jackpot() {
  _impl_.jackpot_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t sc_game_roll::_internal_jackpot() const {
  return _impl_.jackpot_;
}
inline int64_t sc_game_roll::jackpot() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.jackpot)
  return _internal_jackpot();
}
inline void sc_game_roll::_internal_set_jackpot(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.jackpot_ = value;
}
inline void sc_game_roll::set_jackpot(int64_t value) {
  _internal_set_jackpot(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.jackpot)
}

// required int32 winType = 6;
inline bool sc_game_roll::_internal_has_wintype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool sc_game_roll::has_wintype() const {
  return _internal_has_wintype();
}
inline void sc_game_roll::clear_wintype() {
  _impl_.wintype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t sc_game_roll::_internal_wintype() const {
  return _impl_.wintype_;
}
inline int32_t sc_game_roll::wintype() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.winType)
  return _internal_wintype();
}
inline void sc_game_roll::_internal_set_wintype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.wintype_ = value;
}
inline void sc_game_roll::set_wintype(int32_t value) {
  _internal_set_wintype(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.winType)
}

// required int32 freeCount = 7;
inline bool sc_game_roll::_internal_has_freecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool sc_game_roll::has_freecount() const {
  return _internal_has_freecount();
}
inline void sc_game_roll::clear_freecount() {
  _impl_.freecount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t sc_game_roll::_internal_freecount() const {
  return _impl_.freecount_;
}
inline int32_t sc_game_roll::freecount() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.freeCount)
  return _internal_freecount();
}
inline void sc_game_roll::_internal_set_freecount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.freecount_ = value;
}
inline void sc_game_roll::set_freecount(int32_t value) {
  _internal_set_freecount(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.freeCount)
}

// required int32 freeAllCount = 8;
inline bool sc_game_roll::_internal_has_freeallcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool sc_game_roll::has_freeallcount() const {
  return _internal_has_freeallcount();
}
inline void sc_game_roll::clear_freeallcount() {
  _impl_.freeallcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t sc_game_roll::_internal_freeallcount() const {
  return _impl_.freeallcount_;
}
inline int32_t sc_game_roll::freeallcount() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.freeAllCount)
  return _internal_freeallcount();
}
inline void sc_game_roll::_internal_set_freeallcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.freeallcount_ = value;
}
inline void sc_game_roll::set_freeallcount(int32_t value) {
  _internal_set_freeallcount(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.freeAllCount)
}

// required int32 multiple_number = 9;
inline bool sc_game_roll::_internal_has_multiple_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool sc_game_roll::has_multiple_number() const {
  return _internal_has_multiple_number();
}
inline void sc_game_roll::clear_multiple_number() {
  _impl_.multiple_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t sc_game_roll::_internal_multiple_number() const {
  return _impl_.multiple_number_;
}
inline int32_t sc_game_roll::multiple_number() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.multiple_number)
  return _internal_multiple_number();
}
inline void sc_game_roll::_internal_set_multiple_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.multiple_number_ = value;
}
inline void sc_game_roll::set_multiple_number(int32_t value) {
  _internal_set_multiple_number(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.multiple_number)
}

// required int32 multiple_numberFree = 10;
inline bool sc_game_roll::_internal_has_multiple_numberfree() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool sc_game_roll::has_multiple_numberfree() const {
  return _internal_has_multiple_numberfree();
}
inline void sc_game_roll::clear_multiple_numberfree() {
  _impl_.multiple_numberfree_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t sc_game_roll::_internal_multiple_numberfree() const {
  return _impl_.multiple_numberfree_;
}
inline int32_t sc_game_roll::multiple_numberfree() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.multiple_numberFree)
  return _internal_multiple_numberfree();
}
inline void sc_game_roll::_internal_set_multiple_numberfree(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.multiple_numberfree_ = value;
}
inline void sc_game_roll::set_multiple_numberfree(int32_t value) {
  _internal_set_multiple_numberfree(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.multiple_numberFree)
}

// required int64 betScore = 11;
inline bool sc_game_roll::_internal_has_betscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool sc_game_roll::has_betscore() const {
  return _internal_has_betscore();
}
inline void sc_game_roll::clear_betscore() {
  _impl_.betscore_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t sc_game_roll::_internal_betscore() const {
  return _impl_.betscore_;
}
inline int64_t sc_game_roll::betscore() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.betScore)
  return _internal_betscore();
}
inline void sc_game_roll::_internal_set_betscore(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.betscore_ = value;
}
inline void sc_game_roll::set_betscore(int64_t value) {
  _internal_set_betscore(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.betScore)
}

// repeated int32 resultCells = 12;
inline int sc_game_roll::_internal_resultcells_size() const {
  return _impl_.resultcells_.size();
}
inline int sc_game_roll::resultcells_size() const {
  return _internal_resultcells_size();
}
inline void sc_game_roll::clear_resultcells() {
  _impl_.resultcells_.Clear();
}
inline int32_t sc_game_roll::_internal_resultcells(int index) const {
  return _impl_.resultcells_.Get(index);
}
inline int32_t sc_game_roll::resultcells(int index) const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.resultCells)
  return _internal_resultcells(index);
}
inline void sc_game_roll::set_resultcells(int index, int32_t value) {
  _impl_.resultcells_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.resultCells)
}
inline void sc_game_roll::_internal_add_resultcells(int32_t value) {
  _impl_.resultcells_.Add(value);
}
inline void sc_game_roll::add_resultcells(int32_t value) {
  _internal_add_resultcells(value);
  // @@protoc_insertion_point(field_add:pb_game_100018.sc_game_roll.resultCells)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
sc_game_roll::_internal_resultcells() const {
  return _impl_.resultcells_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
sc_game_roll::resultcells() const {
  // @@protoc_insertion_point(field_list:pb_game_100018.sc_game_roll.resultCells)
  return _internal_resultcells();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
sc_game_roll::_internal_mutable_resultcells() {
  return &_impl_.resultcells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
sc_game_roll::mutable_resultcells() {
  // @@protoc_insertion_point(field_mutable_list:pb_game_100018.sc_game_roll.resultCells)
  return _internal_mutable_resultcells();
}

// repeated int32 hitCells = 13;
inline int sc_game_roll::_internal_hitcells_size() const {
  return _impl_.hitcells_.size();
}
inline int sc_game_roll::hitcells_size() const {
  return _internal_hitcells_size();
}
inline void sc_game_roll::clear_hitcells() {
  _impl_.hitcells_.Clear();
}
inline int32_t sc_game_roll::_internal_hitcells(int index) const {
  return _impl_.hitcells_.Get(index);
}
inline int32_t sc_game_roll::hitcells(int index) const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.hitCells)
  return _internal_hitcells(index);
}
inline void sc_game_roll::set_hitcells(int index, int32_t value) {
  _impl_.hitcells_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.hitCells)
}
inline void sc_game_roll::_internal_add_hitcells(int32_t value) {
  _impl_.hitcells_.Add(value);
}
inline void sc_game_roll::add_hitcells(int32_t value) {
  _internal_add_hitcells(value);
  // @@protoc_insertion_point(field_add:pb_game_100018.sc_game_roll.hitCells)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
sc_game_roll::_internal_hitcells() const {
  return _impl_.hitcells_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
sc_game_roll::hitcells() const {
  // @@protoc_insertion_point(field_list:pb_game_100018.sc_game_roll.hitCells)
  return _internal_hitcells();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
sc_game_roll::_internal_mutable_hitcells() {
  return &_impl_.hitcells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
sc_game_roll::mutable_hitcells() {
  // @@protoc_insertion_point(field_mutable_list:pb_game_100018.sc_game_roll.hitCells)
  return _internal_mutable_hitcells();
}

// repeated .pb_game_100018.lineHit hitLines = 14;
inline int sc_game_roll::_internal_hitlines_size() const {
  return _impl_.hitlines_.size();
}
inline int sc_game_roll::hitlines_size() const {
  return _internal_hitlines_size();
}
inline void sc_game_roll::clear_hitlines() {
  _impl_.hitlines_.Clear();
}
inline ::pb_game_100018::lineHit* sc_game_roll::mutable_hitlines(int index) {
  // @@protoc_insertion_point(field_mutable:pb_game_100018.sc_game_roll.hitLines)
  return _impl_.hitlines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb_game_100018::lineHit >*
sc_game_roll::mutable_hitlines() {
  // @@protoc_insertion_point(field_mutable_list:pb_game_100018.sc_game_roll.hitLines)
  return &_impl_.hitlines_;
}
inline const ::pb_game_100018::lineHit& sc_game_roll::_internal_hitlines(int index) const {
  return _impl_.hitlines_.Get(index);
}
inline const ::pb_game_100018::lineHit& sc_game_roll::hitlines(int index) const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.hitLines)
  return _internal_hitlines(index);
}
inline ::pb_game_100018::lineHit* sc_game_roll::_internal_add_hitlines() {
  return _impl_.hitlines_.Add();
}
inline ::pb_game_100018::lineHit* sc_game_roll::add_hitlines() {
  ::pb_game_100018::lineHit* _add = _internal_add_hitlines();
  // @@protoc_insertion_point(field_add:pb_game_100018.sc_game_roll.hitLines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb_game_100018::lineHit >&
sc_game_roll::hitlines() const {
  // @@protoc_insertion_point(field_list:pb_game_100018.sc_game_roll.hitLines)
  return _impl_.hitlines_;
}

// required int64 userScore = 15;
inline bool sc_game_roll::_internal_has_userscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool sc_game_roll::has_userscore() const {
  return _internal_has_userscore();
}
inline void sc_game_roll::clear_userscore() {
  _impl_.userscore_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t sc_game_roll::_internal_userscore() const {
  return _impl_.userscore_;
}
inline int64_t sc_game_roll::userscore() const {
  // @@protoc_insertion_point(field_get:pb_game_100018.sc_game_roll.userScore)
  return _internal_userscore();
}
inline void sc_game_roll::_internal_set_userscore(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.userscore_ = value;
}
inline void sc_game_roll::set_userscore(int64_t value) {
  _internal_set_userscore(value);
  // @@protoc_insertion_point(field_set:pb_game_100018.sc_game_roll.userScore)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb_game_100018

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb_game_100018::cmd_code> : ::std::true_type {};
template <> struct is_proto_enum< ::pb_game_100018::error_code> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pb_5fgame_5f100018_2eproto
