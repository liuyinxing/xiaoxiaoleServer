// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb_game_100018.proto

#include "pb_game_100018.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace pb_game_100018 {
PROTOBUF_CONSTEXPR lineHit::lineHit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellidx_)*/{}
  , /*decltype(_impl_.linenum_)*/0} {}
struct lineHitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR lineHitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~lineHitDefaultTypeInternal() {}
  union {
    lineHit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 lineHitDefaultTypeInternal _lineHit_default_instance_;
PROTOBUF_CONSTEXPR cs_change_bet::cs_change_bet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.basebet_)*/int64_t{0}} {}
struct cs_change_betDefaultTypeInternal {
  PROTOBUF_CONSTEXPR cs_change_betDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~cs_change_betDefaultTypeInternal() {}
  union {
    cs_change_bet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 cs_change_betDefaultTypeInternal _cs_change_bet_default_instance_;
PROTOBUF_CONSTEXPR sc_change_bet::sc_change_bet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.multiple_number_)*/0} {}
struct sc_change_betDefaultTypeInternal {
  PROTOBUF_CONSTEXPR sc_change_betDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~sc_change_betDefaultTypeInternal() {}
  union {
    sc_change_bet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 sc_change_betDefaultTypeInternal _sc_change_bet_default_instance_;
PROTOBUF_CONSTEXPR sc_game_info::sc_game_info(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gameinfo_)*/nullptr
  , /*decltype(_impl_.gameline_)*/0
  , /*decltype(_impl_.defaultbet_)*/0} {}
struct sc_game_infoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR sc_game_infoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~sc_game_infoDefaultTypeInternal() {}
  union {
    sc_game_info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 sc_game_infoDefaultTypeInternal _sc_game_info_default_instance_;
PROTOBUF_CONSTEXPR cs_game_roll::cs_game_roll(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.betscore_)*/int64_t{0}} {}
struct cs_game_rollDefaultTypeInternal {
  PROTOBUF_CONSTEXPR cs_game_rollDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~cs_game_rollDefaultTypeInternal() {}
  union {
    cs_game_roll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 cs_game_rollDefaultTypeInternal _cs_game_roll_default_instance_;
PROTOBUF_CONSTEXPR sc_game_roll::sc_game_roll(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resultcells_)*/{}
  , /*decltype(_impl_.hitcells_)*/{}
  , /*decltype(_impl_.hitlines_)*/{}
  , /*decltype(_impl_.currentmode_)*/0
  , /*decltype(_impl_.nextmode_)*/0
  , /*decltype(_impl_.winscore_)*/int64_t{0}
  , /*decltype(_impl_.freetotalwinscore_)*/int64_t{0}
  , /*decltype(_impl_.jackpot_)*/int64_t{0}
  , /*decltype(_impl_.wintype_)*/0
  , /*decltype(_impl_.freecount_)*/0
  , /*decltype(_impl_.freeallcount_)*/0
  , /*decltype(_impl_.multiple_number_)*/0
  , /*decltype(_impl_.betscore_)*/int64_t{0}
  , /*decltype(_impl_.userscore_)*/int64_t{0}
  , /*decltype(_impl_.multiple_numberfree_)*/0} {}
struct sc_game_rollDefaultTypeInternal {
  PROTOBUF_CONSTEXPR sc_game_rollDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~sc_game_rollDefaultTypeInternal() {}
  union {
    sc_game_roll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 sc_game_rollDefaultTypeInternal _sc_game_roll_default_instance_;
}  // namespace pb_game_100018
namespace pb_game_100018 {
bool cmd_code_IsValid(int value) {
  switch (value) {
    case 80:
    case 83:
    case 180:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> cmd_code_strings[3] = {};

static const char cmd_code_names[] =
  "ass_game_change_bet"
  "ass_game_roll"
  "mdm_game_notify";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry cmd_code_entries[] = {
  { {cmd_code_names + 0, 19}, 83 },
  { {cmd_code_names + 19, 13}, 80 },
  { {cmd_code_names + 32, 15}, 180 },
};

static const int cmd_code_entries_by_number[] = {
  1, // 80 -> ass_game_roll
  0, // 83 -> ass_game_change_bet
  2, // 180 -> mdm_game_notify
};

const std::string& cmd_code_Name(
    cmd_code value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          cmd_code_entries,
          cmd_code_entries_by_number,
          3, cmd_code_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      cmd_code_entries,
      cmd_code_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     cmd_code_strings[idx].get();
}
bool cmd_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, cmd_code* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      cmd_code_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<cmd_code>(int_value);
  }
  return success;
}
bool error_code_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> error_code_strings[3] = {};

static const char error_code_names[] =
  "roll_bet_invalide"
  "roll_mode_is_error"
  "roll_score_not_enough";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry error_code_entries[] = {
  { {error_code_names + 0, 17}, 1 },
  { {error_code_names + 17, 18}, 3 },
  { {error_code_names + 35, 21}, 2 },
};

static const int error_code_entries_by_number[] = {
  0, // 1 -> roll_bet_invalide
  2, // 2 -> roll_score_not_enough
  1, // 3 -> roll_mode_is_error
};

const std::string& error_code_Name(
    error_code value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          error_code_entries,
          error_code_entries_by_number,
          3, error_code_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      error_code_entries,
      error_code_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     error_code_strings[idx].get();
}
bool error_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, error_code* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      error_code_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<error_code>(int_value);
  }
  return success;
}

// ===================================================================

class lineHit::_Internal {
 public:
  using HasBits = decltype(std::declval<lineHit>()._impl_._has_bits_);
  static void set_has_linenum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

lineHit::lineHit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb_game_100018.lineHit)
}
lineHit::lineHit(const lineHit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  lineHit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellidx_){from._impl_.cellidx_}
    , decltype(_impl_.linenum_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.linenum_ = from._impl_.linenum_;
  // @@protoc_insertion_point(copy_constructor:pb_game_100018.lineHit)
}

inline void lineHit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellidx_){arena}
    , decltype(_impl_.linenum_){0}
  };
}

lineHit::~lineHit() {
  // @@protoc_insertion_point(destructor:pb_game_100018.lineHit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void lineHit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cellidx_.~RepeatedField();
}

void lineHit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void lineHit::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_game_100018.lineHit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cellidx_.Clear();
  _impl_.linenum_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* lineHit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 lineNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_linenum(&has_bits);
          _impl_.linenum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 cellIdx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_cellidx(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_cellidx(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* lineHit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_game_100018.lineHit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 lineNum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_linenum(), target);
  }

  // repeated int32 cellIdx = 2;
  for (int i = 0, n = this->_internal_cellidx_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cellidx(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_game_100018.lineHit)
  return target;
}

size_t lineHit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_game_100018.lineHit)
  size_t total_size = 0;

  // required int32 lineNum = 1;
  if (_internal_has_linenum()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_linenum());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 cellIdx = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.cellidx_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_cellidx_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void lineHit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const lineHit*>(
      &from));
}

void lineHit::MergeFrom(const lineHit& from) {
  lineHit* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_game_100018.lineHit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cellidx_.MergeFrom(from._impl_.cellidx_);
  if (from._internal_has_linenum()) {
    _this->_internal_set_linenum(from._internal_linenum());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void lineHit::CopyFrom(const lineHit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_game_100018.lineHit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool lineHit::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void lineHit::InternalSwap(lineHit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cellidx_.InternalSwap(&other->_impl_.cellidx_);
  swap(_impl_.linenum_, other->_impl_.linenum_);
}

std::string lineHit::GetTypeName() const {
  return "pb_game_100018.lineHit";
}


// ===================================================================

class cs_change_bet::_Internal {
 public:
  using HasBits = decltype(std::declval<cs_change_bet>()._impl_._has_bits_);
  static void set_has_basebet(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

cs_change_bet::cs_change_bet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb_game_100018.cs_change_bet)
}
cs_change_bet::cs_change_bet(const cs_change_bet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  cs_change_bet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.basebet_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.basebet_ = from._impl_.basebet_;
  // @@protoc_insertion_point(copy_constructor:pb_game_100018.cs_change_bet)
}

inline void cs_change_bet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.basebet_){int64_t{0}}
  };
}

cs_change_bet::~cs_change_bet() {
  // @@protoc_insertion_point(destructor:pb_game_100018.cs_change_bet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void cs_change_bet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void cs_change_bet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void cs_change_bet::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_game_100018.cs_change_bet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.basebet_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* cs_change_bet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 baseBet = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_basebet(&has_bits);
          _impl_.basebet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* cs_change_bet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_game_100018.cs_change_bet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 baseBet = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_basebet(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_game_100018.cs_change_bet)
  return target;
}

size_t cs_change_bet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_game_100018.cs_change_bet)
  size_t total_size = 0;

  // required int64 baseBet = 1;
  if (_internal_has_basebet()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_basebet());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void cs_change_bet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const cs_change_bet*>(
      &from));
}

void cs_change_bet::MergeFrom(const cs_change_bet& from) {
  cs_change_bet* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_game_100018.cs_change_bet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_basebet()) {
    _this->_internal_set_basebet(from._internal_basebet());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void cs_change_bet::CopyFrom(const cs_change_bet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_game_100018.cs_change_bet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cs_change_bet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void cs_change_bet::InternalSwap(cs_change_bet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.basebet_, other->_impl_.basebet_);
}

std::string cs_change_bet::GetTypeName() const {
  return "pb_game_100018.cs_change_bet";
}


// ===================================================================

class sc_change_bet::_Internal {
 public:
  using HasBits = decltype(std::declval<sc_change_bet>()._impl_._has_bits_);
  static void set_has_multiple_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

sc_change_bet::sc_change_bet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb_game_100018.sc_change_bet)
}
sc_change_bet::sc_change_bet(const sc_change_bet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  sc_change_bet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.multiple_number_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.multiple_number_ = from._impl_.multiple_number_;
  // @@protoc_insertion_point(copy_constructor:pb_game_100018.sc_change_bet)
}

inline void sc_change_bet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.multiple_number_){0}
  };
}

sc_change_bet::~sc_change_bet() {
  // @@protoc_insertion_point(destructor:pb_game_100018.sc_change_bet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void sc_change_bet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void sc_change_bet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void sc_change_bet::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_game_100018.sc_change_bet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.multiple_number_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* sc_change_bet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 multiple_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_multiple_number(&has_bits);
          _impl_.multiple_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* sc_change_bet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_game_100018.sc_change_bet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 multiple_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_multiple_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_game_100018.sc_change_bet)
  return target;
}

size_t sc_change_bet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_game_100018.sc_change_bet)
  size_t total_size = 0;

  // required int32 multiple_number = 1;
  if (_internal_has_multiple_number()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_multiple_number());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void sc_change_bet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const sc_change_bet*>(
      &from));
}

void sc_change_bet::MergeFrom(const sc_change_bet& from) {
  sc_change_bet* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_game_100018.sc_change_bet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_multiple_number()) {
    _this->_internal_set_multiple_number(from._internal_multiple_number());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void sc_change_bet::CopyFrom(const sc_change_bet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_game_100018.sc_change_bet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sc_change_bet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void sc_change_bet::InternalSwap(sc_change_bet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.multiple_number_, other->_impl_.multiple_number_);
}

std::string sc_change_bet::GetTypeName() const {
  return "pb_game_100018.sc_change_bet";
}


// ===================================================================

class sc_game_info::_Internal {
 public:
  using HasBits = decltype(std::declval<sc_game_info>()._impl_._has_bits_);
  static const ::pb_game_100018::sc_game_roll& gameinfo(const sc_game_info* msg);
  static void set_has_gameinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gameline(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_defaultbet(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::pb_game_100018::sc_game_roll&
sc_game_info::_Internal::gameinfo(const sc_game_info* msg) {
  return *msg->_impl_.gameinfo_;
}
sc_game_info::sc_game_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb_game_100018.sc_game_info)
}
sc_game_info::sc_game_info(const sc_game_info& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  sc_game_info* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gameinfo_){nullptr}
    , decltype(_impl_.gameline_){}
    , decltype(_impl_.defaultbet_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_gameinfo()) {
    _this->_impl_.gameinfo_ = new ::pb_game_100018::sc_game_roll(*from._impl_.gameinfo_);
  }
  ::memcpy(&_impl_.gameline_, &from._impl_.gameline_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.defaultbet_) -
    reinterpret_cast<char*>(&_impl_.gameline_)) + sizeof(_impl_.defaultbet_));
  // @@protoc_insertion_point(copy_constructor:pb_game_100018.sc_game_info)
}

inline void sc_game_info::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gameinfo_){nullptr}
    , decltype(_impl_.gameline_){0}
    , decltype(_impl_.defaultbet_){0}
  };
}

sc_game_info::~sc_game_info() {
  // @@protoc_insertion_point(destructor:pb_game_100018.sc_game_info)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void sc_game_info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.gameinfo_;
}

void sc_game_info::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void sc_game_info::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_game_100018.sc_game_info)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.gameinfo_ != nullptr);
    _impl_.gameinfo_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.gameline_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.defaultbet_) -
        reinterpret_cast<char*>(&_impl_.gameline_)) + sizeof(_impl_.defaultbet_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* sc_game_info::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .pb_game_100018.sc_game_roll gameinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 gameLine = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameline(&has_bits);
          _impl_.gameline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 defaultBet = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_defaultbet(&has_bits);
          _impl_.defaultbet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* sc_game_info::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_game_100018.sc_game_info)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .pb_game_100018.sc_game_roll gameinfo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::gameinfo(this),
        _Internal::gameinfo(this).GetCachedSize(), target, stream);
  }

  // required int32 gameLine = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_gameline(), target);
  }

  // required int32 defaultBet = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_defaultbet(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_game_100018.sc_game_info)
  return target;
}

size_t sc_game_info::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb_game_100018.sc_game_info)
  size_t total_size = 0;

  if (_internal_has_gameinfo()) {
    // required .pb_game_100018.sc_game_roll gameinfo = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.gameinfo_);
  }

  if (_internal_has_gameline()) {
    // required int32 gameLine = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gameline());
  }

  if (_internal_has_defaultbet()) {
    // required int32 defaultBet = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defaultbet());
  }

  return total_size;
}
size_t sc_game_info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_game_100018.sc_game_info)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .pb_game_100018.sc_game_roll gameinfo = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.gameinfo_);

    // required int32 gameLine = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gameline());

    // required int32 defaultBet = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defaultbet());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void sc_game_info::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const sc_game_info*>(
      &from));
}

void sc_game_info::MergeFrom(const sc_game_info& from) {
  sc_game_info* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_game_100018.sc_game_info)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_gameinfo()->::pb_game_100018::sc_game_roll::MergeFrom(
          from._internal_gameinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gameline_ = from._impl_.gameline_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.defaultbet_ = from._impl_.defaultbet_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void sc_game_info::CopyFrom(const sc_game_info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_game_100018.sc_game_info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sc_game_info::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_gameinfo()) {
    if (!_impl_.gameinfo_->IsInitialized()) return false;
  }
  return true;
}

void sc_game_info::InternalSwap(sc_game_info* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(sc_game_info, _impl_.defaultbet_)
      + sizeof(sc_game_info::_impl_.defaultbet_)
      - PROTOBUF_FIELD_OFFSET(sc_game_info, _impl_.gameinfo_)>(
          reinterpret_cast<char*>(&_impl_.gameinfo_),
          reinterpret_cast<char*>(&other->_impl_.gameinfo_));
}

std::string sc_game_info::GetTypeName() const {
  return "pb_game_100018.sc_game_info";
}


// ===================================================================

class cs_game_roll::_Internal {
 public:
  using HasBits = decltype(std::declval<cs_game_roll>()._impl_._has_bits_);
  static void set_has_betscore(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

cs_game_roll::cs_game_roll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb_game_100018.cs_game_roll)
}
cs_game_roll::cs_game_roll(const cs_game_roll& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  cs_game_roll* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.betscore_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.betscore_ = from._impl_.betscore_;
  // @@protoc_insertion_point(copy_constructor:pb_game_100018.cs_game_roll)
}

inline void cs_game_roll::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.betscore_){int64_t{0}}
  };
}

cs_game_roll::~cs_game_roll() {
  // @@protoc_insertion_point(destructor:pb_game_100018.cs_game_roll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void cs_game_roll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void cs_game_roll::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void cs_game_roll::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_game_100018.cs_game_roll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.betscore_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* cs_game_roll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 betScore = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_betscore(&has_bits);
          _impl_.betscore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* cs_game_roll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_game_100018.cs_game_roll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 betScore = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_betscore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_game_100018.cs_game_roll)
  return target;
}

size_t cs_game_roll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_game_100018.cs_game_roll)
  size_t total_size = 0;

  // required int64 betScore = 1;
  if (_internal_has_betscore()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_betscore());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void cs_game_roll::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const cs_game_roll*>(
      &from));
}

void cs_game_roll::MergeFrom(const cs_game_roll& from) {
  cs_game_roll* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_game_100018.cs_game_roll)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_betscore()) {
    _this->_internal_set_betscore(from._internal_betscore());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void cs_game_roll::CopyFrom(const cs_game_roll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_game_100018.cs_game_roll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cs_game_roll::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void cs_game_roll::InternalSwap(cs_game_roll* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.betscore_, other->_impl_.betscore_);
}

std::string cs_game_roll::GetTypeName() const {
  return "pb_game_100018.cs_game_roll";
}


// ===================================================================

class sc_game_roll::_Internal {
 public:
  using HasBits = decltype(std::declval<sc_game_roll>()._impl_._has_bits_);
  static void set_has_currentmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nextmode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_winscore(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_freetotalwinscore(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_jackpot(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_wintype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_freecount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_freeallcount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_multiple_number(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_multiple_numberfree(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_betscore(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_userscore(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000fff) ^ 0x00000fff) != 0;
  }
};

sc_game_roll::sc_game_roll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb_game_100018.sc_game_roll)
}
sc_game_roll::sc_game_roll(const sc_game_roll& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  sc_game_roll* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resultcells_){from._impl_.resultcells_}
    , decltype(_impl_.hitcells_){from._impl_.hitcells_}
    , decltype(_impl_.hitlines_){from._impl_.hitlines_}
    , decltype(_impl_.currentmode_){}
    , decltype(_impl_.nextmode_){}
    , decltype(_impl_.winscore_){}
    , decltype(_impl_.freetotalwinscore_){}
    , decltype(_impl_.jackpot_){}
    , decltype(_impl_.wintype_){}
    , decltype(_impl_.freecount_){}
    , decltype(_impl_.freeallcount_){}
    , decltype(_impl_.multiple_number_){}
    , decltype(_impl_.betscore_){}
    , decltype(_impl_.userscore_){}
    , decltype(_impl_.multiple_numberfree_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.currentmode_, &from._impl_.currentmode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.multiple_numberfree_) -
    reinterpret_cast<char*>(&_impl_.currentmode_)) + sizeof(_impl_.multiple_numberfree_));
  // @@protoc_insertion_point(copy_constructor:pb_game_100018.sc_game_roll)
}

inline void sc_game_roll::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resultcells_){arena}
    , decltype(_impl_.hitcells_){arena}
    , decltype(_impl_.hitlines_){arena}
    , decltype(_impl_.currentmode_){0}
    , decltype(_impl_.nextmode_){0}
    , decltype(_impl_.winscore_){int64_t{0}}
    , decltype(_impl_.freetotalwinscore_){int64_t{0}}
    , decltype(_impl_.jackpot_){int64_t{0}}
    , decltype(_impl_.wintype_){0}
    , decltype(_impl_.freecount_){0}
    , decltype(_impl_.freeallcount_){0}
    , decltype(_impl_.multiple_number_){0}
    , decltype(_impl_.betscore_){int64_t{0}}
    , decltype(_impl_.userscore_){int64_t{0}}
    , decltype(_impl_.multiple_numberfree_){0}
  };
}

sc_game_roll::~sc_game_roll() {
  // @@protoc_insertion_point(destructor:pb_game_100018.sc_game_roll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void sc_game_roll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resultcells_.~RepeatedField();
  _impl_.hitcells_.~RepeatedField();
  _impl_.hitlines_.~RepeatedPtrField();
}

void sc_game_roll::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void sc_game_roll::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_game_100018.sc_game_roll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.resultcells_.Clear();
  _impl_.hitcells_.Clear();
  _impl_.hitlines_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.currentmode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.freeallcount_) -
        reinterpret_cast<char*>(&_impl_.currentmode_)) + sizeof(_impl_.freeallcount_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.multiple_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.multiple_numberfree_) -
        reinterpret_cast<char*>(&_impl_.multiple_number_)) + sizeof(_impl_.multiple_numberfree_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* sc_game_roll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 currentMode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_currentmode(&has_bits);
          _impl_.currentmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 nextMode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nextmode(&has_bits);
          _impl_.nextmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 winScore = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_winscore(&has_bits);
          _impl_.winscore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 freetotalwinScore = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_freetotalwinscore(&has_bits);
          _impl_.freetotalwinscore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 jackpot = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_jackpot(&has_bits);
          _impl_.jackpot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 winType = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_wintype(&has_bits);
          _impl_.wintype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 freeCount = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_freecount(&has_bits);
          _impl_.freecount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 freeAllCount = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_freeallcount(&has_bits);
          _impl_.freeallcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 multiple_number = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_multiple_number(&has_bits);
          _impl_.multiple_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 multiple_numberFree = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_multiple_numberfree(&has_bits);
          _impl_.multiple_numberfree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 betScore = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_betscore(&has_bits);
          _impl_.betscore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 resultCells = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_resultcells(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<uint8_t>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_resultcells(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 hitCells = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_hitcells(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_hitcells(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .pb_game_100018.lineHit hitLines = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hitlines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required int64 userScore = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_userscore(&has_bits);
          _impl_.userscore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* sc_game_roll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_game_100018.sc_game_roll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 currentMode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_currentmode(), target);
  }

  // required int32 nextMode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nextmode(), target);
  }

  // required int64 winScore = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_winscore(), target);
  }

  // required int64 freetotalwinScore = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_freetotalwinscore(), target);
  }

  // required int64 jackpot = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_jackpot(), target);
  }

  // required int32 winType = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_wintype(), target);
  }

  // required int32 freeCount = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_freecount(), target);
  }

  // required int32 freeAllCount = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_freeallcount(), target);
  }

  // required int32 multiple_number = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_multiple_number(), target);
  }

  // required int32 multiple_numberFree = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_multiple_numberfree(), target);
  }

  // required int64 betScore = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_betscore(), target);
  }

  // repeated int32 resultCells = 12;
  for (int i = 0, n = this->_internal_resultcells_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_resultcells(i), target);
  }

  // repeated int32 hitCells = 13;
  for (int i = 0, n = this->_internal_hitcells_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_hitcells(i), target);
  }

  // repeated .pb_game_100018.lineHit hitLines = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hitlines_size()); i < n; i++) {
    const auto& repfield = this->_internal_hitlines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required int64 userScore = 15;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_userscore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_game_100018.sc_game_roll)
  return target;
}

size_t sc_game_roll::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pb_game_100018.sc_game_roll)
  size_t total_size = 0;

  if (_internal_has_currentmode()) {
    // required int32 currentMode = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_currentmode());
  }

  if (_internal_has_nextmode()) {
    // required int32 nextMode = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nextmode());
  }

  if (_internal_has_winscore()) {
    // required int64 winScore = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_winscore());
  }

  if (_internal_has_freetotalwinscore()) {
    // required int64 freetotalwinScore = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_freetotalwinscore());
  }

  if (_internal_has_jackpot()) {
    // required int64 jackpot = 5;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_jackpot());
  }

  if (_internal_has_wintype()) {
    // required int32 winType = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wintype());
  }

  if (_internal_has_freecount()) {
    // required int32 freeCount = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_freecount());
  }

  if (_internal_has_freeallcount()) {
    // required int32 freeAllCount = 8;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_freeallcount());
  }

  if (_internal_has_multiple_number()) {
    // required int32 multiple_number = 9;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_multiple_number());
  }

  if (_internal_has_betscore()) {
    // required int64 betScore = 11;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_betscore());
  }

  if (_internal_has_userscore()) {
    // required int64 userScore = 15;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_userscore());
  }

  if (_internal_has_multiple_numberfree()) {
    // required int32 multiple_numberFree = 10;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_multiple_numberfree());
  }

  return total_size;
}
size_t sc_game_roll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_game_100018.sc_game_roll)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000fff) ^ 0x00000fff) == 0) {  // All required fields are present.
    // required int32 currentMode = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_currentmode());

    // required int32 nextMode = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nextmode());

    // required int64 winScore = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_winscore());

    // required int64 freetotalwinScore = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_freetotalwinscore());

    // required int64 jackpot = 5;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_jackpot());

    // required int32 winType = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wintype());

    // required int32 freeCount = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_freecount());

    // required int32 freeAllCount = 8;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_freeallcount());

    // required int32 multiple_number = 9;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_multiple_number());

    // required int64 betScore = 11;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_betscore());

    // required int64 userScore = 15;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_userscore());

    // required int32 multiple_numberFree = 10;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_multiple_numberfree());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 resultCells = 12;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.resultcells_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_resultcells_size());
    total_size += data_size;
  }

  // repeated int32 hitCells = 13;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.hitcells_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_hitcells_size());
    total_size += data_size;
  }

  // repeated .pb_game_100018.lineHit hitLines = 14;
  total_size += 1UL * this->_internal_hitlines_size();
  for (const auto& msg : this->_impl_.hitlines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void sc_game_roll::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const sc_game_roll*>(
      &from));
}

void sc_game_roll::MergeFrom(const sc_game_roll& from) {
  sc_game_roll* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_game_100018.sc_game_roll)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.resultcells_.MergeFrom(from._impl_.resultcells_);
  _this->_impl_.hitcells_.MergeFrom(from._impl_.hitcells_);
  _this->_impl_.hitlines_.MergeFrom(from._impl_.hitlines_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.currentmode_ = from._impl_.currentmode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nextmode_ = from._impl_.nextmode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.winscore_ = from._impl_.winscore_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.freetotalwinscore_ = from._impl_.freetotalwinscore_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.jackpot_ = from._impl_.jackpot_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.wintype_ = from._impl_.wintype_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.freecount_ = from._impl_.freecount_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.freeallcount_ = from._impl_.freeallcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.multiple_number_ = from._impl_.multiple_number_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.betscore_ = from._impl_.betscore_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.userscore_ = from._impl_.userscore_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.multiple_numberfree_ = from._impl_.multiple_numberfree_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void sc_game_roll::CopyFrom(const sc_game_roll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_game_100018.sc_game_roll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sc_game_roll::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.hitlines_))
    return false;
  return true;
}

void sc_game_roll::InternalSwap(sc_game_roll* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.resultcells_.InternalSwap(&other->_impl_.resultcells_);
  _impl_.hitcells_.InternalSwap(&other->_impl_.hitcells_);
  _impl_.hitlines_.InternalSwap(&other->_impl_.hitlines_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(sc_game_roll, _impl_.multiple_numberfree_)
      + sizeof(sc_game_roll::_impl_.multiple_numberfree_)
      - PROTOBUF_FIELD_OFFSET(sc_game_roll, _impl_.currentmode_)>(
          reinterpret_cast<char*>(&_impl_.currentmode_),
          reinterpret_cast<char*>(&other->_impl_.currentmode_));
}

std::string sc_game_roll::GetTypeName() const {
  return "pb_game_100018.sc_game_roll";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace pb_game_100018
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pb_game_100018::lineHit*
Arena::CreateMaybeMessage< ::pb_game_100018::lineHit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb_game_100018::lineHit >(arena);
}
template<> PROTOBUF_NOINLINE ::pb_game_100018::cs_change_bet*
Arena::CreateMaybeMessage< ::pb_game_100018::cs_change_bet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb_game_100018::cs_change_bet >(arena);
}
template<> PROTOBUF_NOINLINE ::pb_game_100018::sc_change_bet*
Arena::CreateMaybeMessage< ::pb_game_100018::sc_change_bet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb_game_100018::sc_change_bet >(arena);
}
template<> PROTOBUF_NOINLINE ::pb_game_100018::sc_game_info*
Arena::CreateMaybeMessage< ::pb_game_100018::sc_game_info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb_game_100018::sc_game_info >(arena);
}
template<> PROTOBUF_NOINLINE ::pb_game_100018::cs_game_roll*
Arena::CreateMaybeMessage< ::pb_game_100018::cs_game_roll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb_game_100018::cs_game_roll >(arena);
}
template<> PROTOBUF_NOINLINE ::pb_game_100018::sc_game_roll*
Arena::CreateMaybeMessage< ::pb_game_100018::sc_game_roll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb_game_100018::sc_game_roll >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
